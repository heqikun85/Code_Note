[返回首页](./1.Spring概念.md)

# 注解
[@Component 注解](#table1)
[纯注解开发](#table2)

### 注解注入bean
1. Spring可以通过注解的方式将bean返回给实例
2. 所谓注解就是在@后命令名，通过一个名称告知java之后的一些规则。
   （@Override 就是注解的一种）
3. 核心注解命令：
   1. `@Override`：重写interface或者parent class的method function。
   2. [**`@Component`**：使用bean，格式：`@Component("BeanName")`](#table1)
     `@Component` 有三个衍生注解
      1. **`@Controller`**: 用于表现层（界面之类）bean
      2. **`@Service`**: 用于业务层（逻辑功能）
      3. **`@Repository`**: 用于数据层（数据库数据之类）

### <a id="table1">@Component 注解设置bean</a>
通过Componenet注解我们可以不用在Spring框架内手动设置bean。格式：
```java
// 挂载注释的格式：context:component-scan 前缀。
// base-package 必要项（required）
// 跟class 所在的文件地址
<context:componennt-scan base-package="org.example.dao.Impl"/>
```

```java
    // 引用Spring构建的对象时，@Component要放在最外层class名和 import之间
    // 两种方式皆可，@Component
    @Component
    // @Component(className)，取名之后可以使用第一第二种调用方式
    @Component("sDao")
    

    public class SpringServiceImpl implements SpringService {
    private SpringDao springDao;

```

* **注1**：`base-pacakge`后面的地址可以是大范围地址。这样，Spring就会在这个文件夹下大范围搜索所有实现类
* 比如`<context:component-scan base-package="org.example"/>` 
* **注2**：不同的 **`@Component`** 注解方式，调用时需要注意调用方式
  ```java
        // 已命名的component
        SpringDao s1 = (SpringDao) ctx.getBean("sDao");
        SpringDao s2 = ctx.getBean("sDao", SpringDao.class);
        System.out.println(s1);
        System.out.println(s2);

        // 未命名component
        SpringDao s1 = ctx.getBean(SpringDaoImpl.class);
        System.out.println(s1);
  ```

* **注3**： **`@Component`** 平时不用，都分别以不同class的归属使用 **`@controller`**， **`@Service`**， **`@Repository`**. 功能是一样的，主要用以区分不同的业务层，让代码可读性更高。

### <a id="table2">纯注解开发</a>
纯注解开发是可以脱离xml文件的。也就是说，纯注解开发，我们能够抛开之前注入式开发时要创建一个xml文件去注入bean的方式。

我们需要在Service（业务层） / Dao（数据层）等平行位置设立一个配置层。
![image](./image/1721023976866.jpg)

从图片上我们能看到，最下面的xml文件已经被改名，无法被调用了

配置文件中代码如下：
```java
<!--config file-->
/* package 和 import省略不写了，可自动生成
 * Configuration 是Spring框架中配置的注解，功能为：
 * 1. 将原本xml中的bean依赖代码注入到配置注释中
 * 2. 将配置文件作为配置bean的入口。
 */ 
@Configuration
/* 扫描所标示目录下的所有bean class，这两条都写在最外层class和import之间。
 * 该条注释只能使用一次，如果需要多个路径，可以使用数组的形式：
 * @ComponentScan({"org.example.dao", "org.example.service", ...})
 */ 
@ComponentScan("org.example")
public class springconfig {
}

<!--main中的object创建需要修改-->
// 大部分import都会自动生成
public class App {
    public static void main(String[] args) {
        // 创建的spring object 管理对象为 AnnotationConfigApplicationContext(configFileName.class)
        ApplicationContext ctx = new AnnotationConfigApplicationContext(springconfig.class);
    }
}
```

### <a id="table2">纯注解开发Bean的单例和多例</a>
单例（只创建一个object，内存地址不变）
多例（创建多个object，内存地址变）
使用 **`@Scope`** 注解来简单标注Bean是单例还是多例
```java
    @Scope // 默认单例
    @Scope("singleton")
    @Scope("prototype")  // 多例
```

### 纯注解生命周期
```java
    <!--执行实例class内-->
    /* function那么不重要，重要的是注解
     * @PostConstructor 和 @PreDstroy 都是在javax.annotation的jar包
     * 这两个实现一个在构造后，一个在销毁前。
     */
    @PostConstruct
    public void init() {
        System.out.println("init。。。");
    }
    @PreDestroy
    public void destory() {
        System.out.println("destory。。。");
    }

    <!--mian file-->
    // 调用那两个功能，不能使用多态创建object。
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(springconfig.class);

    // 销毁程序需要程序关闭对象。
    ctx.close();
```