## 生命周期和模版引用，以及侦听器

[返回首页](./vue教程.md)

1. [生命周期和模板引用](#table1)
2. [侦听器（有异步function的写法）](#table2)

### <a id= "table1">生命周期和模板引用</a>

Vue的响应式和声明式在大部分情况下可以自动更新DOM，但也需要手动更新，这时我们需要使用模板引用——也就是指向模板中一个 DOM 元素的 ref。  
我们需要通过这个特殊的 ref attribute 来实现模板引用： `<p ref="pElementRef">hello</p>`

要访问该引用，我们需要声明一个同名的 ref：`const pElementRef = ref(null)`  
注意这个 ref 使用 null 值来初始化。这是因为当 `<script setup>` 执行时，DOM 元素还不存在。模板引用 ref 只能在组件挂载后访问。  
要在挂载之后执行代码，我们可以使用 onMounted() 函数：  
```js
import { onMounted } from 'vue'

onMounted(() => {
  // 此时组件已经挂载。
})
```

这被称为生命周期钩子——它允许我们注册一个在组件的特定生命周期调用的回调函数。  
还有一些其他的钩子如 onUpdated 和 onUnmounted。

```js
<script setup>
import { ref , onMounted} from 'vue'

// 通过onMounted组件，来更改p的内容，在 `<p>` 内使用了`ref = “pElementRef”`，这样能通过更改pElementRef来更改相应内容
onMounted(()=>{
  pElementRef.value.textContent = "mounted"
})
const pElementRef = ref(null)
</script>

<template>
  <p ref="pElementRef">Hello</p>
</template>
```

### <a id= "table2">侦听器（有异步function的写法）</a>

`import { ref, watch } from 'vue'`这是监听器的pack

```js
watch(count, (newCount) => {
  // 没错，console.log() 是一个副作用
  console.log(`new count is: ${newCount}`)
})
```
基本语法为，watch（监控对象，function）


```js
<script setup>
import { ref, watch } from 'vue'

const todoId = ref(1)
const todoData = ref(null)

//这是一个异步抓取信息的 function， 注意异步的写法，以后可以用到
async function fetchData() {
  todoData.value = null
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  todoData.value = await res.json()
}

fetchData()
  
watch(todoId, fetchData)
</script>

<template>
  <p>Todo id: {{ todoId }}</p>
  <button @click="todoId++" :disabled="!todoData">Fetch next todo</button>
  <p v-if="!todoData">Loading...</p>
  <pre v-else>{{ todoData }}</pre>
</template>
```